using System.Globalization;
using System.Linq;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Exercise 1: " + String.Join(", ", Ex1(new int[] { -1, 2, -3, 4 })));
        Console.WriteLine("Exercise 2: " + Ex2(2, new int[] { -11, 43, -42, 32 }));
        Console.WriteLine("Exercise 3: " + Ex3(4, new string[] { "1. Дана цілочисленна послідовність",
                                                                "2. Дана цифра D",
                                                                "3. Дано ціле число L (> 0) та строкова послідовність A",
                                                                "4. Дан символ С и строковая последовательность A",
                                                                "4. M",
                                                                "4. I",
                                                                "5. Дано символ С та строкова послідовність A" }));
        Console.WriteLine("Exercise 4: " + Ex4('C', new string[] { "Once meeted persons of Frankivsk, Kyiv, Kherson and Kharkiv",
                                                                "Kyiv: I love programming on Java",
                                                                "Kherson: I love programming on C#",
                                                                "Frankivs: I'm so strange, I write a code in a notebook and programming on C++",
                                                                "Kharkiv: I'm a freak. I love tomato juice and programming on C",}));
        Console.WriteLine("Exercise 5: " + Ex5('C', new string[] { "C++ or C",
                                                                "C or C++",
                                                                "C# or C"}));
        Console.WriteLine("Exercise 6: " + Ex6(new string[] { "C++ or C",
                                                                "C or C++",
                                                                "C# or C"}));
        Console.WriteLine("Exercise 7: " + String.Join(", ", Ex7(new int[] { -18, -15, -2, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 8: " + String.Join(", ", Ex8(new int[] { -18, -15, -2, -1, 0, 404, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 9: " + Ex9(new int[] { -11, 43, -42, 32 }));
        Console.WriteLine("Exercise 10: " + Ex10(4, new string[] { "Odesa", "Kyiv", "Lviv", "Kherson" }));
        Console.WriteLine("Exercise 11: " + Ex11(new string[] { "Kyiv", "Frankivsk", "Crimea" }));
        Console.WriteLine("Exercise 12: " + Ex12(new int[] { 18, 1, 0, 1, 4, 17, 1 }));
        Console.WriteLine("Exercise 13: " + Ex13(3));
        Console.WriteLine("Exercise 14: " + Ex14(2, 3));
        Console.WriteLine("Exercise 15: " + Ex15(10));
        Console.WriteLine("Exercise 16: " + String.Join(", ", Ex16(new int[] { -1, 2, -3, 4 })));
        Console.WriteLine("Exercise 17: " + String.Join(", ", Ex17(new int[] { -18, -15, -2, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 18: " + String.Join(", ", Ex18(new int[] { -18, -15, -2, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 19: " + String.Join(", ", Ex19(1, new int[] { -181, -15, -2, -1, 0, 1, 4, 171, 1 })));
        Console.WriteLine("Exercise 20: " + String.Join(", ", Ex20(new int[] { -18, -15, -2, -1, 0, 404, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 21: " + String.Join(", ", Ex21(new string[] { "B", "YYY", "AAA", "A", "AA" })));
        Console.WriteLine("Exercise 22: " + String.Join(", ", Ex22(3, new string[] { "B", "YY3", "AA3", "CC0", "A", "AA" })));
        Console.WriteLine("Exercise 23: " + String.Join(", ", Ex23(4, new int[] { -181, -15, -2, -1, 0, 1, 4, 171, 5 })));
        Console.WriteLine("Exercise 24: " + String.Join(", ", Ex24(2, new string[] { "ABC", "def", "ghI", "JKL", "NOPQ", "RSTUV" })));
        Console.WriteLine("Exercise 25: " + Ex25(1, 6, new int[] { 181, 15, 2, 1, 0, 1, 4, 171, 1 }));
        Console.WriteLine("Exercise 26: " + Ex26(1, 3, new string[] { "A", "BC", "DEF", "GHIJ", "KLMNO", "PQRSTU" }));
        Console.WriteLine("Exercise 27: " + String.Join(", ", Ex27(3, new int[] { -18, -15, -2, -1, 0, 2, 1, 404, 17, 5 })));
        Console.WriteLine("Exercise 28: " + String.Join(", ", Ex28(3, new string[] { "YYY", "A", "B2", "DEF", "GHIJ", "KLMN4", "PQRSTU", "YYYYYY" })));
        Console.WriteLine("Exercise 29: " + String.Join(", ", Ex29(20, 5, new int[] { 18, 15, 2, 1, 100, 404, 1, 4, 18 })));
        Console.WriteLine("Exercise 30: " + String.Join(", ", Ex30(5, new int[] { 18, 15, 2, 1, 100, 404, 1, 4, 18 })));
        Console.WriteLine("Exercise 31: " + String.Join(", ", Ex31(5, new string[] { "YYY", "A", "B2", "DEF", "GHIJ", "KLMN4", "PQRSTU", "YYYYYY" })));
        Console.WriteLine("Exercise 32: " + String.Join(", ", Ex32(new string[] { "abc", "def", "gh" })));
        Console.WriteLine("Exercise 33: " + String.Join(", ", Ex33(new int[] { -18, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 34: " + String.Join(", ", Ex34(new int[] { 18, 1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 35: " + String.Join(", ", Ex35(new int[] { 18, 1, 0, 3, 4, 17, 1 })));
        Console.WriteLine("Exercise 36: " + String.Join(", ", Ex36(new string[] { "Once meeted persons of Frankivsk, Kyiv, Kherson and Kharkiv",
                                                                "Kyiv: I love programming on Java",
                                                                "Kherson: I love programming on C#",
                                                                "Frankivs: I'm so strange, I write a code in a notebook and programming on C++",
                                                                "Kharkiv: I'm a freak. I love tomato juice and programming on C",})));
        Console.WriteLine("Exercise 37: " + String.Join(", ", Ex37(new string[] { "", "ABC", "DEF", "GHI", "JKL", "NOPQ", "RSTUV" })));
        Console.WriteLine("Exercise 38: " + String.Join(", ", Ex38(new int[] { -18, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 39: " + String.Join(", ", Ex39(new string[] { "My", "n1ckname", "1s", "M00nWalker" })));
        Console.WriteLine("Exercise 40: " + String.Join(", ", Ex40(4, new string[] { "where", "we", "were", "at", "the", "week" })));
        Console.WriteLine("Exercise 41: " + String.Join(" ", Ex41(9, new string[] { "Greetings", "!So,.tell.me", "about.yourself!" })));
        Console.WriteLine("Exercise 42: " + String.Join(", ", Ex42(new string[] { "My", "n1ckname", "1s", "M00nWalker" })));
        Console.WriteLine("Exercise 43: " + String.Join(", ", Ex43(2, new string[] { "My", "n1ckname", "1s", "M00nWalker" })));
        Console.WriteLine("Exercise 44: " + String.Join(", ", Ex44(2, 3, new int[] { -5, -1, 1, -2, 2, 5, 4 }, new int[] { -4, -3, 2, 6 })));
        Console.WriteLine("Exercise 45: " + String.Join(", ", Ex45(5, 2, new string[] { "This", "is", "first", "array" }, new string[] { "So", "this", "is", "second", "array" })));
        Console.WriteLine("Exercise 46: " + String.Join(", ", Ex46(new int[] { 18, 45, 129 }, new int[] { 15, 49, 88 })));
        Console.WriteLine("Exercise 47: " + String.Join(", ", Ex47(new int[] { 18, 45, 49 }, new int[] { 51, 921, 88 })));
        Console.WriteLine("Exercise 48: " + String.Join(", ", Ex48(new string[] { "AAA", "A", "AA" }, new string[] { "YYY", "B2", "C" })));
        Console.WriteLine("Exercise 49: " + String.Join(", ", Ex49(new string[] { "ALPHA", "B", "ALPHA" }, new string[] { "A", "B2", "ABC" }, new string[] { "BMW", "AUDI", "A3" })));
        Console.WriteLine("Exercise 50: " + String.Join(", ", Ex50(new string[] { "This", "is", "first", "array" }, new string[] { "So", "This", "is", "second", "array" })));
        Console.WriteLine("Exercise 51: " + String.Join(", ", Ex51(new int[] { 1, 2, 3, 4 }, new int[] { 51, 11, 6, 3, 44 })));
        Console.WriteLine("Exercise 52: " + String.Join(", ", Ex52(new string[] { "Thi5", "i5", "firs1", "array" }, new string[] { "S0", "Thi5", "i5", "second", "array" })));
        Console.WriteLine("Exercise 53: " + String.Join(", ", Ex53(new int[] { 1, 2, 3, 4 }, new int[] { 5, 6, 7, 8 })));
        Console.WriteLine("Exercise 54: " + String.Join(", ", Ex54(new string[] { "MSB", "B2", "A" }, new string[] { "BMW", "A3", "C" })));
        Console.WriteLine("Exercise 55: " + String.Join(", ", Ex55(new int[] { 19, 41, 41 }, new int[] { 1, 39, 23 })));
        Console.WriteLine("Exercise 56: " + String.Join(", ", Ex56(new int[] { -18, -15, -1, 405, 1, 8 })));
        Console.WriteLine("Exercise 57: " + String.Join(", ", Ex57(new int[] { -18, -15, -1, 405, 1, 8 })));
        Console.WriteLine("Exercise 58: " + String.Join(", ", Ex58(new string[] { "THIS", "IS", "ARRAY", "OR", "THEY'RE", "ARRAYS" })));
        Console.WriteLine("Exercise 59: " + String.Join(", ", Ex59(new string[] { "THIS", "IS", "FIRST", "ARRAY" })));
        Console.WriteLine("Exercise 60: " + String.Join(", ", Ex60(new string[] { "LA", "LA", "LA", "WAY", "LA", "LA", "LA", "WAY", "LA", "LA", "LA", "HEY", "LA", "LA", "LA", "HEY" })));
    }

    /* Дана целочисленная последовательность, содержащая как положительные,
    так и отрицательные числа. Вывести ее первый положительный элемент и
    последний отрицательный элемент.*/
    static int[] Ex1(int[] Input)
    {
        int[] result = new int[2];
        result[0] = Input.First(i => i > 0);
        result[1] = Input.Last(i => i < 0);
        return result;
    }

    /* Дана цифра D (однозначное целое число) и целочисленная
    последовательность A. Вывести первый положительный элемент
    последовательности A, оканчивающийся цифрой D. Если требуемых элементов
    в последовательности A нет, то вывести 0.*/
    static int Ex2(int D, int[] A) => A.FirstOrDefault(i => i >= 0 && i % 10 == D, 0);

    /*Дано целое число L (> 0) и строковая последовательность A. Вывести
    последнюю строку из A, начинающуюся с цифры и имеющую длину L. Если
    ребуемых строк в последовательности A нет, то вывести строку «Not found».*/
    static string Ex3(int L, string[] A) => A.LastOrDefault(i => i.First().ToString() == L.ToString() && i.Length == L, "Not found");

    /*Дан символ С и строковая последовательность A.
    Если A содержит единственный элемент, оканчивающийся символом C, то вывести этот элемент;
    если требуемых строк в A нет, то вывести пустую строку;
    если требуемых строк больше одной, то вывести строку «Error».*/
    static string Ex4(char C, string[] A)
    {
        try
        {
            return A.SingleOrDefault(i => i.Last() == C, "");
        }
        catch (System.Exception)
        {
            return "Error";
        }
    }

    /*Дан символ С и строковая последовательность A. Найти
    количество элементов A, которые содержат более одного символа и при этом
    начинаются и оканчиваются символом C.*/
    static int Ex5(char C, string[] A) => A.Where(i => i.Length > 1 && i.First() == C && i.Last() == C).Count();

    /*Дана строковая последовательность. Найти сумму длин всех строк,
    входящих в данную последовательность.*/
    static int Ex6(string[] A) => A.Sum(i => i.Length);

    /*Дана целочисленная последовательность. Найти количество
    ее отрицательных элементов, а также их сумму. Если отрицательные элементы отсутствуют,
    то дважды вывести 0.*/
    static int[] Ex7(int[] A)
    {
        int[] result = new int[2];
        result[0] = A.Count(i => i < 0);
        result[1] = A.Sum(i => i < 0 ? i : 0);
        return result;
    }

    /*Дана целочисленная последовательность. Найти количество ее
    положительных двузначных элементов, а также их среднее арифметическое
    (как вещественное число). Если требуемые элементы отсутствуют,
    то дважды вывести 0 (первый раз как целое, второй — как вещественное).*/
    static int[] Ex8(int[] A)
    {
        int[] result = new int[2];
        result[0] = A.Count(i => i >= 0 && Math.Abs(i) < 100);
        result[1] = Convert.ToInt32(A.Where(i => i >= 0 && Math.Abs(i) < 100).Average());
        return result;
    }

    /*Дана целочисленная последовательность. Вывести ее минимальный положительный элемент
    или число 0, если последовательность не содержит положительных элементов.*/
    static int Ex9(int[] A) => A.Where(i => i >= 0).Order().FirstOrDefault(0);

    /*Дано целое число L (> 0) и строковая последовательность A.
    Строки последовательности A содержат только заглавные буквы латинского алфавита.
    Среди всех строк из A, имеющих длину L, найти наибольшую
    (в смысле лексикографического порядка).
    Вывести эту строку или пустую строку, если последовательность
    не содержит строк длины L.*/
    static string? Ex10(int L, string[] A) => A.Where(i => i.Length == L).Max();

    /*Дана последовательность непустых строк. Используя метод Aggregate,
    получить строку, состоящую из начальных символов всех строк исходной последовательности.*/
    static string Ex11(string[] str) => str.Aggregate("", (first, next) => first + next.First());

    /*Дана целочисленная последовательность. Используя метод Aggregate,
    найти произведение последних цифр всех элементов последовательности. Чтобы избежать целочисленного переполнения,
    при вычислении произведения использовать вещественный числовой тип.*/
    static long Ex12(int[] A) => A.Aggregate(0, (x, y) => x + y % 10);

    /*Дано целое число N (> 0).
    Используя методы Range и Sum, найти сумму 1 + (1/2) + … + (1/N) (как вещественное число).*/
    static double Ex13(int N) => Enumerable.Range(1, N).Sum(i => (double)1 / i);

    /*Даны целые числа A и B (A < B). Используя методы Range и Average,
    найти среднее арифметическое квадратов всех целых чисел от A до B включительно:
    (A2 + (A+1)2 + … + B2)/(B − A + 1) (как вещественное число).*/
    static double Ex14(int A, int B) => Enumerable.Range(A * 2, B * 2).Average();

    /*Дано целое число N (0 ≤ N ≤ 15). Используя методы Range и Aggregate,
    найти факториал числа N: N! = 1·2·…·N при N ≥ 1; 0! = 1. Чтобы избежать целочисленного переполнения,
    при вычислении факториала использовать вещественный числовой тип.*/
    static long Ex15(int N) => Enumerable.Range(1, N).Aggregate((x, y) => x * y);

    /* Дана целочисленная последовательность. Извлечь из нее все
    положительные числа, сохранив их исходный порядок следования.*/
    static int[] Ex16(int[] Input) => Input.Where(i => i >= 0).ToArray();

    /*Дана целочисленная последовательность. Извлечь из нее все нечетные числа,
    сохранив их исходный порядок следования и удалив все вхождения
    повторяющихся элементов, кроме первых.*/
    static int[] Ex17(int[] Input) => Input.Where(i => i % 2 != 0).Distinct().ToArray();

    /*Дана целочисленная последовательность. Извлечь из нее все четные
    отрицательные числа, поменяв порядок извлеченных чисел на обратный.*/
    static int[] Ex18(int[] Input) => Input.Where(i => i < 0 && i % 2 == 0).Reverse().ToArray();

    /*Дана цифра D (целое однозначное число) и целочисленная последовательность A.
    Извлечь из A все различные положительные числа, оканчивающиеся цифрой D
    (в исходном порядке). При наличии повторяющихся элементов удалять все их вхождения,
    кроме последних.*/
    static int[] Ex19(int D, int[] A) => A.Where(i => i > 0 && i % 10 == D).Distinct().ToArray();

    /*Дана целочисленная последовательность. Извлечь из нее все
    положительные двузначные числа, отсортировав их по возрастанию.*/
    static int[] Ex20(int[] Input) => Input.Where(i => i >= 0 && Math.Abs(i) < 100).Order().ToArray();

    /*Дана строковая последовательность. Строки последовательности содержат
    только заглавные буквы латинского алфавита. Отсортировать последовательность
    по возрастанию длин строк,
    а строки одинаковой длины — в лексикографическом порядке по убыванию.*/
    static string[] Ex21(string[] Input) => Input.Order().OrderBy(i => i.Length).ToArray();

    /*Дано целое число K (> 0) и строковая последовательность A.
    Строки последовательности содержат только цифры и
    заглавные буквы латинского алфавита. Извлечь из A все строки длины K,
    оканчивающиеся цифрой, отсортировав их в лексикографическом порядке по возрастанию.*/
    static string[] Ex22(int K, string[] A) => A.Where(i => i.Length == K && Char.IsDigit(i.Last())).Order().ToArray();

    /* Дано целое число K (> 0) и целочисленная последовательность A.
    Начиная с элемента A с порядковым номером K, извлечь из A все
    нечетные двузначные числа, отсортировав их по убыванию.*/
    static int[] Ex23(int K, int[] A) => A.Skip(K).Where(i => i % 2 != 0 && i < 100).OrderDescending().ToArray();

    /*Дано целое число K (> 0) и строковая последовательность A.
    Из элементов A, предшествующих элементу с порядковым номером K,
    извлечь те строки, которые имеют нечетную длину и начинаются с
    заглавной латинской буквы, изменив порядок следования извлеченных строк на обратный.*/
    static string[] Ex24(int K, string[] A) => A.Skip(K).Where(i => i.Length % 2 != 0 && Char.IsUpper(i.First())).Reverse().ToArray();

    /*Даны целые числа K1 и K2 и целочисленная последовательность A; 1 ≤ K1 < K2 ≤ N, где N — размер последовательности A.
    Найти сумму положительных элементов последовательности с порядковыми номерами от K1 до K2 включительно.*/
    static int Ex25(int k1, int k2, int[] A) => A.Skip(k1).Take(k2 - k1 + 1).Sum();

    /*Даны целые числа K1 и K2 и последовательность непустых строк A; 1 < K1 < K2 ≤ N, где N — размер последовательности A.
    Найти среднее арифметическое длин всех элементов последовательности,
    кроме элементов с порядковыми номерами от K1 до K2 включительно, и вывести его как вещественное число.*/
    static double Ex26(int k1, int k2, string[] A) => A.Except(A.Skip(k1).SkipLast(k2)).Average(i => i.Length);

    /*Дано целое число D и целочисленная последовательность A. Начиная с первого элемента A, большего D,
    извлечь из A все нечетные положительные числа, поменяв порядок извлеченных чисел на обратный.*/
    static int[] Ex27(int D, int[] A) => A.SkipWhile(i => i < D).Where(i => i > 0 && i % 2 != 0).Reverse().ToArray();

    /*Дано целое число L (> 0) и последовательность непустых строк A. Строки последовательности содержат только цифры
    и заглавные буквы латинского алфавита.
    Из элементов A, предшествующих первому элементу, длина которого превышает L, извлечь строки, оканчивающиеся буквой.
    Полученную последовательность отсортировать по убыванию длин строк,
    а строки одинаковой длины — в лексикографическом порядке по возрастанию.*/
    static string[] Ex28(int L, string[] A) => A.TakeWhile(i => i.Length <= L).Where(i => Char.IsLetter(i.Last())).Order().OrderByDescending(i => i.Length).ToArray();

    /*Даны целые числа D и K (K > 0) и целочисленная последовательность A.
    Найти теоретико-множественное объединение двух фрагментов A: первый содержит все элементы до первого элемента,
    большего D (не включая его), а второй — все элементы, начиная с элемента с порядковым номером K.
    Полученную последовательность (не содержащую одинаковых элементов) отсортировать по убыванию.*/
    static int[] Ex29(int D, int K, int[] A) => A.TakeWhile(i => i <= D).Intersect(A.Skip(K)).OrderDescending().ToArray();

    /*Дано целое число K (> 0) и целочисленная последовательность A.
    Найти теоретико-множественную разность двух фрагментов A:
    первый содержит все четные числа, а второй — все числа с порядковыми номерами, большими K.
    В полученной последовательности (не содержащей одинаковых элементов) поменять порядок элементов на обратный.*/
    static int[] Ex30(int K, int[] A) => A.Where(i => i % 2 == 0).Except(A.Skip(K)).Distinct().Reverse().ToArray();

    /*Дано целое число K (> 0) и последовательность непустых строк A.
    Строки последовательности содержат только цифры и заглавные буквы латинского алфавита.
    Найти теоретико-множественное пересечение двух фрагментов A: первый содержит K начальных элементов,
    а второй — все элементы, расположенные после последнего элемента, оканчивающегося цифрой.
    Полученную последовательность (не содержащую одинаковых элементов) отсортировать по возрастанию длин строк,
    а строки одинаковой длины — в лексикографическом порядке по возрастанию.*/
    static string[] Ex31(int K, string[] A) => A.Take(K).Union(A.Reverse().TakeWhile(i => Char.IsDigit(i.Last()))).Order().OrderByDescending(i => i.Length).ToArray();

    /*Дана последовательность непустых строк A. Получить последовательность
    символов, каждый элемент которой является начальным символом
    соответствующей строки из A. Порядок символов должен быть обратным
    по отношению к порядку элементов исходной последовательности.*/
    static string[] Ex32(string[] a) => a.Select(i => i.First().ToString()).Reverse().ToArray();

    /*Дана целочисленная последовательность. Обрабатывая только положительные
    числа, получить последовательность их последних цифр и удалить в полученной
    последовательности все вхождения одинаковых цифр, кроме первого. Порядок
    полученных цифр должен соответствовать порядку исходных чисел.*/
    static int[] Ex33(int[] numbers) => numbers.Where(i => i >= 0).Select(i => i % 10).Distinct().ToArray();

    /*Дана последовательность положительных целых чисел. Обрабатывая только
    нечетные числа, получить последовательность их строковых представлений и
    отсортировать ее в лексикографическом порядке по возрастанию.*/
    static string[] Ex34(int[] numbers) => numbers.Where(i => i % 2 != 0).Select(i => i.ToString()).OrderDescending().ToArray();

    /*Дана целочисленная последовательность. Получить последовательность чисел,
    каждый элемент которой равен произведению соответствующего элемента
    исходной последовательности на его порядковый номер (1, 2, …).
    В полученной последовательности удалить все элементы, не являющиеся двузначными,
    и поменять порядок оставшихся элементов на обратный.*/
    static int[] Ex35(int[] numbers) => numbers.Where((elem, index) => elem < 100 && elem == index).Reverse().ToArray();

    /*Дана последовательность непустых строк. Получить последовательность символов,
    которая определяется следующим образом: если соответствующая строка
    исходной последовательности имеет нечетную длину, то в качестве символа
    берется первый символ этой строки; в противном случае берется последний символ строки.
    Отсортировать полученные символы по убыванию их кодов.*/
    static char[] Ex36(string[] str) => str.Select(i => i.Length % 2 == 0 ? i.Last() : i.First()).Order().ToArray();

    /*Дана строковая последовательность A. Строки последовательности содержат
    только заглавные буквы латинского алфавита. Получить новую
    последовательность строк, элементы которой определяются по
    соответствующим элементам A следующим образом: пустые строки в новую последовательность
    не включаются, а к непустым приписывается порядковый номер данной строки в
    исходной последовательности (например, если пятый элемент A имеет вид «ABC»,
    то в полученной последовательности он будет иметь вид «ABC5»).
    При нумерации должны учитываться и пустые строки последовательности A.
    Отсортировать полученную последовательность в лексикографическом порядке по возрастанию.*/
    static string[] Ex37(string[] A) => A.Select((element, index) => element + index).Where(i => i.Length > 1).ToArray();

    /*Дана целочисленная последовательность A. Получить новую последовательность чисел, элементы
    которой определяются по соответствующим элементам последовательности A следующим образом:
    если порядковый номер элемента A делится на 3 (3, 6, …), то этот элемент в новую последовательность не включается;
    если остаток от деления порядкового номера на 3 равен 1 (1, 4, …), то
    в новую последовательность добавляется удвоенное значение этого элемента;
    в противном случае (для элементов A с номерами 2, 5, …) элемент добавляется в новую последовательность без изменений.
    В полученной последовательности сохранить исходный порядок следования элементов.*/
    static int[] Ex38(int[] A) => A.Where((element, index) => index % 3 != 0).Select((element, index) => index % 3 == 1 ? element * 2 : element).ToArray();

    /*Дана строковая последовательность A. Получить последовательность цифровых символов,
    входящих в строки последовательности A (символы могут повторяться).
    Порядок символов должен соответствовать порядку строк A и порядку следования символов в
    каждой строке.*/
    static char[] Ex39(string[] A) => A.SelectMany(j => j.Where(i => Char.IsDigit(i))).ToArray();

    /*Дано число K (> 0) и строковая последовательность A. Получить последовательность символов,
    содержащую символы всех строк из A, имеющих длину, большую или равную K (символы могут повторяться).
    В полученной последовательности поменять порядок элементов на обратный.*/
    // In my mind, it can be in single line
    static char[] Ex40(int K, string[] A)
    {
        char[] result = A.Where(i => i.Length >= K).First().ToCharArray();
        foreach (string element in A.Where(i => i.Length >= K))
            result = result.Intersect(element.ToCharArray()).ToArray();
        return result;
    }

    /*Дано целое число K (> 0) и строковая последовательность A. Каждый элемент последовательности представляет собой
    несколько слов из заглавных латинских букв, разделенных символами «.» (точка). Получить последовательность строк,
    содержащую все слова длины K из элементов A в лексикографическом порядке по возрастанию (слова могут повторяться).*/
    static string[] Ex41(int K, string[] A) => A.SelectMany(i => i.Split('.')).Where(i => i.Length == K).Order().ToArray();

    /*Дана последовательность непустых строк. Получить последовательность символов, которая определяется следующим образом:
    для строк с нечетными порядковыми номерами (1, 3, …) в последовательность символов включаются все прописные латинские буквы,
    содержащиеся в этих строках, а для строк с четными номерами (2, 4, …) — все их строчные латинские буквы.
    В полученной последовательности символов сохранить их исходный порядок следования.*/
    static char[] Ex42(string[] A) => A.SelectMany((element, index) => index % 2 == 0 ? element.Where(i => Char.IsLower(i)) : element.Where(i => !Char.IsLower(i))).ToArray();

    /*Дано целое число K (> 0) и последовательность непустых строк A.
    Получить последовательность символов, которая определяется следующим образом:
    для первых K элементов последовательности A в новую последовательность заносятся символы,
    стоящие на нечетных позициях данной строки (1, 3, …), а для остальных элементов A — символы на четных позициях (2, 4, …).
    В полученной последовательности поменять порядок элементов на обратный.*/
    static char[] Ex43(int K, string[] A) => A.Take(K).SelectMany(i => i.Where((element, index) => index % 2 == 0)).Concat(A.Skip(K).SelectMany(i => i.Where((element, index) => index % 2 != 0))).ToArray();

    /*Даны целые числа K1 и K2 и целочисленные последовательности A и B.
    Получить последовательность, содержащую все числа из A, большие K1,
    и все числа из B, меньшие K2. Отсортировать полученную последовательность
    по возрастанию.*/
    static int[] Ex44(int k1, int k2, int[] a, int[] b) => a.Where(i => i > k1).Concat(b.Where(i => i < k2)).Order().ToArray();

    /*Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
    Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита.
    Получить последовательность, содержащую все строки из A длины L1
    и все строки из B длины L2. Отсортировать полученную последовательность
    в лексикографическом порядке по убыванию.*/
    static string[] Ex45(int l1, int l2, string[] A, string[] B) => A.Where(i => i.Length == l1).Concat(B.Where(i => i.Length == l2)).Order().ToArray();

    /*Даны последовательности положительных целых чисел A и B; все числа
    в каждой последовательности различны. Найти последовательность всех пар чисел,
    удовлетворяющих следующим условиям: первый элемент пары принадлежит
    последовательности A, второй принадлежит B, и оба элемента оканчиваются
    одной и той же цифрой. Результирующая последовательность называется
    внутренним объединением последовательностей A и B по ключу,
    определяемому последними цифрами исходных чисел.
    Представить найденное объединение в виде последовательности строк,
    содержащих первый и второй элементы пары, разделенные дефисом, например,
    «49-129». Порядок следования пар должен определяться
    исходным порядком элементов последовательности A,
    а для равных первых элементов — порядком элементов последовательности B.*/
    static string[] Ex46(int[] A, int[] B) => A.Join(B, i => i % 10, j => j % 10, (i, j) => new { num1 = i, num2 = j }).Select(i => i.num1 + "-" + i.num2).ToArray();

    /*Даны последовательности положительных целых чисел A и B; все числа в каждой последовательности различны.
    Найти внутреннее объединение A и B (см. LinqBegin46), пары в котором должны удовлетворять следующему условию:
    последняя цифра первого элемента пары (из A) должна совпадать с первой цифрой второго элемента пары (из B).
    Представить найденное объединение в виде последовательности строк, содержащих первый и второй элементы пары,
    разделенные двоеточием, например, «49:921». Порядок следования пар должен определяться исходным порядком элементов
    последовательности A, а для равных первых элементов пар — лексикографическим порядком строковых представлений
    вторых элементов (по возрастанию).*/
    static string[] Ex47(int[] A, int[] B) => A.Join(B, i => i.ToString().Last(), j => j.ToString().First(), (i, j) => new { num1 = i, num2 = j }).Select(i => i.num1 + ":" + i.num2).ToArray();

    /*Даны строковые последовательности A и B; все строки в каждой последовательности различны, имеют ненулевую длину
     и содержат только цифры и заглавные буквы латинского алфавита. Найти внутреннее объединение A и B (см. LinqBegin46),
     каждая пара которого должна содержать строки одинаковой длины. Представить найденное объединение
     в виде последовательности строк, содержащих первый и второй элементы пары, разделенные двоеточием, например, «AB:CD».
     Порядок следования пар должен определяться лексикографическим порядком первых элементов пар (по возрастанию),
     а для равных первых элементов — лексикографическим порядком вторых элементов пар (по убыванию).*/
    static string[] Ex48(string[] A, string[] B) => A.Join(B, i => i.Length, j => j.Length, (i, j) => new { str1 = i, str2 = j }).OrderByDescending(i => i.str2).OrderBy(i => i.str1).Select(i => i.str1 + ":" + i.str2).ToArray();

    /* Даны строковые последовательности A, B и С; все строки в каждой последовательности различны, имеют ненулевую длину и содержат только цифры и 
     * заглавные буквы латинского алфавита. Найти внутреннее объединение A, B и С (см. LinqBegin46), каждая тройка которого должна содержать строки, начинающиеся с одного и того же 
     * символа. Представить найденное объединение в виде последовательности строк вида «EA=EB=EC», где EA, EB, EC — элементы из A, B, C соответственно. 
     * Для различных элементов EA сохраняется исходный порядок их следования, для равных элементов EA порядок троек определяется лексикографическим порядком элементов EB 
     * (по возрастанию), а для равных элементов EA и EB — лексикографическим порядком элементов EC (по убыванию).*/
    // Is it correct?
    static string[] Ex49(string[] A, string[] B, string[] C) => A.Join(B.Join(C, i => i.First(), j => j.First(), (i, j) => new { str2 = i, str3 = j }).OrderByDescending(i => i.str3).OrderBy(i => i.str2), i => i.First(), j => j.str2.First(), (i, j) => new { str1 = i, str2 = j.str2, str3 = j.str3 }).Distinct().Select(i => i.str1 + "=" + i.str2 + "=" + i.str3).ToArray();

    /*Даны строковые последовательности A и B; все строки в каждой последовательности различны и имеют ненулевую длину. Получить последовательность строк вида «E:N», 
     * где E обозначает один из элементов последовательности A, а N — количество элементов из B, начинающихся с того же символа, что и элемент E (например, «abc:4»); 
     * количество N может быть равно 0. Порядок элементов полученной последовательности должен определяться исходным порядком элементов последовательности A.*/
    static string[] Ex50(string[] A, string[] B) => A.GroupJoin(B, i => i.First(), j => j.First(), (i, j) => new { str = i, collection = j }).Select(i => i.str + "." + i.collection.Count()).ToArray();

    /*Даны последовательности положительных целых чисел A и B; все числа в последовательности A различны. Получить последовательность строк вида «S:E», 
     * где S обозначает сумму тех чисел из B, которые оканчиваются на ту же цифру, что и число E — один из элементов последовательности A (например, «74:23»); 
     * если для числа E не найдено ни одного подходящего числа из последовательности B, то в качестве S указать 0. Расположить элементы полученной последовательности 
     * по возрастанию значений найденных сумм, а при равных суммах — по убыванию значений элементов A.*/
    static string[] Ex51(int[] A, int[] B) => A.GroupJoin(B, i => i % 10, j => j % 10, (i, j) => new { number = i, collection = j }).OrderByDescending(i => i.number).OrderBy(i => i.collection.Sum()).Select(i => i.collection.Sum() + "." + i.number).ToArray();

    /*Даны строковые последовательности A и B; все строки в каждой последовательности различны, имеют ненулевую длину и содержат только цифры и заглавные буквы латинского алфавита. 
     * Получить последовательность всевозможных комбинаций вида «EA=EB», где EA — некоторый элемент из A, EB — некоторый элемент из B, 
     * причем оба элемента оканчиваются цифрой (например, «AF3=D78»). Упорядочить полученную последовательность в лексикографическом порядке по возрастанию элементов EA, 
     * а при одинаковых элементах EA — в лексикографическом порядке по убыванию элементов EB.*/
    static string[] Ex52(string[] A, string[] B) => A.Where(i => Char.IsDigit(i.Last())).Join(B.Where(i => Char.IsDigit(i.Last())), i => true, j => true, (i, j) => new { str1 = i, str2 = j }).Select(i => i.str1 + "=" + i.str2).ToArray();

    /*Даны целочисленные последовательности A и B. Получить последовательность всех различных сумм, в которых первое слагаемое берется из A, а второе из B. 
     * Упорядочить полученную последовательность по возрастанию.*/
    static int[] Ex53(int[] A, int[] B) => A.Join(B, i => true, j => true, (i, j) => i + j).ToArray();

    /*Даны строковые последовательности A и B;
    все строки в каждой последовательности различны, имеют ненулевую длину и содержат только цифры
    и заглавные буквы латинского алфавита. Найти последовательность всех пар строк,
    удовлетворяющих следующим условиям: первый элемент пары принадлежит последовательности A,
    а второй либо является одним из элементов последовательности B, начинающихся с того же символа,
    что и первый элемент пары, либо является пустой строкой (если B не содержит ни одной подходящей строки).
    Результирующая последовательность называется левым внешним объединением последовательностей A и B по ключу,
    определяемому первыми символами исходных строк. Представить найденное объединение в виде последовательности строк вида «EA.EB»,
    где EA — элемент из A, а EB — либо один из соответствующих ему элементов из B, либо пустая строка.
    Расположить элементы полученной строковой последовательности в лексикографическом порядке по возрастанию.
    Указание. Использовать методы GroupJoin, DefaultIfEmpty, Select и SelectMany.*/
    static string[] Ex54(string[] A, string[] B) => A.GroupJoin(B, i => i.First(), j => j.First(), (i, j) => new { first = i, second = j.DefaultIfEmpty("") }).OrderBy(i => i.first).SelectMany(i => i.second.Select(j => i.first + "." + j)).ToArray();

    /*Даны последовательности положительных целых чисел A и B; все числа в каждой последовательности различны. Найти левое внешнее объединение A и B (см. LinqBegin54), 
     * пары в котором должны удовлетворять следующему условию: оба элемента пары оканчиваются одной и той же цифрой. 
     * Представить найденное объединение в виде последовательности строк вида «EA:EB», где EA — число из A, а EB — либо одно из соответствующих ему чисел из B, 
     * либо 0 (если в B не содержится чисел, соответствующих EA). Расположить элементы полученной последовательности по убыванию чисел EA, 
     * а при одинаковых числах EA — по возрастанию чисел EB.*/
    // M - m - m...
    static string[] Ex55(int[] A, int[] B) => A.GroupJoin(B, i => i % 10, j => j % 10, (i, j) => new { first = i, second = j.DefaultIfEmpty(0) }).OrderByDescending(i => i.first).SelectMany(i => i.second.Select(j => i.first + "." + j)).ToArray();

    /*Дана целочисленная последовательность A. Сгруппировать элементы последовательности A,
    оканчивающиеся одной и той же цифрой, и на основе этой группировки получить последовательность строк вида «D:S»,
    где D — ключ группировки (т. е. некоторая цифра, которой оканчивается хотя бы одно из чисел последовательности A),
    а S — сумма всех чисел из A, которые оканчиваются цифрой D. Полученную последовательность упорядочить по возрастанию ключей.
    Указание. Использовать метод GroupBy.*/
    static string[] Ex56(int[] A) => A.GroupBy(i => Math.Abs(i) % 10).Select(i => i.Key + ":" + i.Sum()).ToArray();

    /*Дана целочисленная последовательность. Среди всех элементов последовательности, оканчивающихся одной и той же цифрой,
    выбрать максимальный. Полученную последовательность максимальных элементов упорядочить по возрастанию их последних цифр.*/
    static int[] Ex57(int[] A) => A.GroupBy(i => Math.Abs(i) % 10).Select(i => i.Max()).OrderBy(i => i % 10).ToArray();

    /*Дана последовательность непустых строк. Среди всех строк, начинающихся с одного и того же символа,
    выбрать наиболее длинную. Если таких строк несколько, то выбрать первую по порядку их следования в
    исходной последовательности. Полученную последовательность строк упорядочить по возрастанию кодов их начальных символов.*/
    static string[] Ex58(string[] A) => A.GroupBy(i => i.First()).Select(i => i.MaxBy(j => j.Length)).OrderBy(i => i!.Length).ToArray()!;

    /*Дана последовательность непустых строк, содержащих только заглавные буквы латинского алфавита.
    Среди всех строк одинаковой длины выбрать первую в лексикографическом порядке (по возрастанию).
    Полученную последовательность строк упорядочить по убыванию их длин.*/
    static string[] Ex59(string[] A) => A.GroupBy(i => i.Length).Select(i => i.Min()).OrderByDescending(i => i!.Length).ToArray()!;

    /*Дана последовательность непустых строк A, содержащих
    только заглавные буквы латинского алфавита. Для всех строк,
    начинающихся с одной и той же буквы, определить их суммарную длину
    и получить последовательность строк вида «S-C», где S — суммарная длина всех строк
    из A, которые начинаются с буквы С. Полученную последовательность упорядочить
    по убыванию числовых значений сумм,
    а при равных значениях сумм — по возрастанию кодов символов C.*/
    static string[] Ex60(string[] str) => str.Select(i => new { chr = i.First(), Count = str.Sum(j => j.First() == i.First() ? j.Length : 0) }).Distinct().OrderBy(i => i.chr).OrderByDescending(i => i.Count).Select(i => i.Count.ToString() + "-" + i.chr.ToString()).ToArray();
}
