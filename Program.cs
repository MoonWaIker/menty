class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Exercise 1: " + String.Join(", ", Ex1(new int[] { -1, 2, -3, 4 })));
        Console.WriteLine("Exercise 2: " + Ex2(2, new int[] { -11, 43, -42, 32 }));
        Console.WriteLine("Exercise 3: " + Ex3(4, new string[] { "1. Дана цілочисленна послідовність",
                                                                "2. Дана цифра D",
                                                                "3. Дано ціле число L (> 0) та строкова послідовність A",
                                                                "4. Дан символ С и строковая последовательность A",
                                                                "4. M",
                                                                "4. I",
                                                                "5. Дано символ С та строкова послідовність A" }));
        Console.WriteLine("Exercise 4: " + Ex4('C', new string[] { "Once meeted persons of Frankivsk, Kyiv, Kherson and Kharkiv",
                                                                "Kyiv: I love programming on Java",
                                                                "Kherson: I love programming on C#",
                                                                "Frankivs: I'm so strange, I write a code in a notebook and programming on C++",
                                                                "Kharkiv: I'm a freak. I love tomato juice and programming on C",}));
        Console.WriteLine("Exercise 5: " + Ex5('C', new string[] { "C++ or C",
                                                                "C or C++",
                                                                "C# or C"}));
        Console.WriteLine("Exercise 6: " + Ex6(new string[] { "C++ or C",
                                                                "C or C++",
                                                                "C# or C"}));
        Console.WriteLine("Exercise 7: " + String.Join(", ", Ex7(new int[] { -18, -15, -2, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 8: " + String.Join(", ", Ex8(new int[] { -18, -15, -2, -1, 0, 404, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 9: " + Ex9(new int[] { -11, 43, -42, 32 }));
        Console.WriteLine("Exercise 10: " + Ex10(4, new string[] { "Odesa", "Kyiv", "Lviv", "Kherson" }));
        Console.WriteLine("Exercise 16: " + String.Join(", ", Ex16(new int[] { -1, 2, -3, 4 })));
        Console.WriteLine("Exercise 17: " + String.Join(", ", Ex17(new int[] { -18, -15, -2, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 18: " + String.Join(", ", Ex18(new int[] { -18, -15, -2, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 19: " + String.Join(", ", Ex19(1 , new int[] { -181, -15, -2, -1, 0, 1, 4, 171, 1 })));
        Console.WriteLine("Exercise 20: " + String.Join(", ", Ex20(new int[] { -18, -15, -2, -1, 0, 404, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 21: " + String.Join(", ", Ex21(new string[] { "B", "YYY", "AAA", "A", "AA" })));
        Console.WriteLine("Exercise 22: " + String.Join(", ", Ex22(3, new string[] { "B", "YY3", "AA3", "CC0", "A", "AA" })));
        Console.WriteLine("Exercise 23: " + String.Join(", ", Ex23(4, new int[] { -181, -15, -2, -1, 0, 1, 4, 171, 5 })));
        Console.WriteLine("Exercise 24: " + String.Join(", ", Ex24(2, new string[] { "ABC", "def", "ghI", "JKL", "NOPQ", "RSTUV" })));
        Console.WriteLine("Exercise 32: " + String.Join(", ", Ex32(new string[] { "abc", "def", "gh" })));
        Console.WriteLine("Exercise 33: " + String.Join(", ", Ex33(new int[] { -18, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 34: " + String.Join(", ", Ex34(new int[] { 18, 1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 35: " + String.Join(", ", Ex35(new int[] { 18, 1, 0, 3, 4, 17, 1 })));
        Console.WriteLine("Exercise 36: " + String.Join(", ", Ex36(new string[] { "Once meeted persons of Frankivsk, Kyiv, Kherson and Kharkiv",
                                                                "Kyiv: I love programming on Java",
                                                                "Kherson: I love programming on C#",
                                                                "Frankivs: I'm so strange, I write a code in a notebook and programming on C++",
                                                                "Kharkiv: I'm a freak. I love tomato juice and programming on C",})));
        Console.WriteLine("Exercise 37: " + String.Join(", ", Ex37(new string[] { "", "ABC", "DEF", "GHI", "JKL", "NOPQ", "RSTUV" })));
        Console.WriteLine("Exercise 38: " + String.Join(", ", Ex38(new int[] { -18, -1, 0, 1, 4, 17, 1 })));
        Console.WriteLine("Exercise 39: " + String.Join(", ", Ex39(new string[] { "My", "n1ckname", "1s", "M00nWalker" })));
        Console.WriteLine("Exercise 44: " + String.Join(", ", Ex44(2, 3, new int[] { -5, -1, 1, -2, 2, 5, 4 }, new int[] { -4, -3, 2, 6 })));
        Console.WriteLine("Exercise 45: " + String.Join(", ", Ex45(5, 2, new string[] { "This", "is", "first", "array" }, new string[] {"So", "this", "is", "second", "array"})));
        Console.WriteLine("Exercise 56: " + String.Join(", ", Ex56(new int[] { -18, -15, -1, 405, 1, 8 })));
        Console.WriteLine("Exercise 57: " + String.Join(", ", Ex57(new int[] { -18, -15, -1, 405, 1, 8 })));
        Console.WriteLine("Exercise 58: " + String.Join(", ", Ex58(new string[] { "THIS", "IS", "ARRAY", "OR", "THEY'RE", "ARRAYS" })));
        Console.WriteLine("Exercise 59: " + String.Join(", ", Ex59(new string[] { "THIS", "IS", "FIRST", "ARRAY" })));
        Console.WriteLine("Exercise 60: " + String.Join(", ", Ex60(new string[] { "LA", "LA", "LA", "WAY", "LA", "LA", "LA", "WAY", "LA", "LA", "LA", "HEY", "LA", "LA", "LA", "HEY" })));
    }

    /* Дана целочисленная последовательность, содержащая как положительные,
    так и отрицательные числа. Вывести ее первый положительный элемент и
    последний отрицательный элемент.*/
    static int[] Ex1(int[] Input)
    {
        int[] result = new int[2];
        result[0] = Input.First(i => i > 0);
        result[1] = Input.Last(i => i < 0);
        return result;
    }

    /* Дана цифра D (однозначное целое число) и целочисленная
    последовательность A. Вывести первый положительный элемент
    последовательности A, оканчивающийся цифрой D. Если требуемых элементов
    в последовательности A нет, то вывести 0.*/
    static int Ex2(int D, int[] A) => A.FirstOrDefault(i => i >= 0 && i%10 == D,0);

    /*Дано целое число L (> 0) и строковая последовательность A. Вывести
    последнюю строку из A, начинающуюся с цифры и имеющую длину L. Если
    ребуемых строк в последовательности A нет, то вывести строку «Not found».*/
    static string Ex3(int L, string[] A) => A.LastOrDefault(i => i.First().ToString() == L.ToString() && i.Length == L, "Not found");

    /*Дан символ С и строковая последовательность A.
    Если A содержит единственный элемент, оканчивающийся символом C, то вывести этот элемент;
    если требуемых строк в A нет, то вывести пустую строку;
    если требуемых строк больше одной, то вывести строку «Error».*/
    static string Ex4(char C, string[] A)
    {
        try
        {
            return A.SingleOrDefault(i => i.Last() == C, "");
        }
        catch (System.Exception)
        {
            return "Error";
        }
    }

    /*Дан символ С и строковая последовательность A. Найти
    количество элементов A, которые содержат более одного символа и при этом
    начинаются и оканчиваются символом C.*/
    static int Ex5(char C, string[] A) => A.Where(i => i.Length > 1 && i.First() == C && i.Last() == C).Count();

    /*Дана строковая последовательность. Найти сумму длин всех строк,
    входящих в данную последовательность.*/
    static int Ex6(string[] A) => A.Sum(i => i.Length);

    /*Дана целочисленная последовательность. Найти количество
    ее отрицательных элементов, а также их сумму. Если отрицательные элементы отсутствуют,
    то дважды вывести 0.*/
    static int[] Ex7(int[] A)
    {
        int[] result = new int[2];
        result[0] = A.Count(i => i < 0);
        result[1] = A.Sum(i => i < 0 ? i : 0);
        return result;
    }

    /*Дана целочисленная последовательность. Найти количество ее
    положительных двузначных элементов, а также их среднее арифметическое
    (как вещественное число). Если требуемые элементы отсутствуют,
    то дважды вывести 0 (первый раз как целое, второй — как вещественное).*/
    static int[] Ex8(int[] A)
    {
        int[] result = new int[2];
        result[0] = A.Count(i => i >= 0 && Math.Abs(i) < 100);
        result[1] = Convert.ToInt32(A.Where(i => i >= 0 && Math.Abs(i) < 100).Average());
        return result;
    }

    /*Дана целочисленная последовательность. Вывести ее минимальный положительный элемент
    или число 0, если последовательность не содержит положительных элементов.*/
    static int Ex9(int[] A) => A.Where(i => i >= 0).Order().FirstOrDefault(0);

    /*Дано целое число L (> 0) и строковая последовательность A.
    Строки последовательности A содержат только заглавные буквы латинского алфавита.
    Среди всех строк из A, имеющих длину L, найти наибольшую
    (в смысле лексикографического порядка).
    Вывести эту строку или пустую строку, если последовательность
    не содержит строк длины L.*/
    static string? Ex10(int L, string[] A) => A.Where(i => i.Length == L).Max();

    /* Дана целочисленная последовательность. Извлечь из нее все
    положительные числа, сохранив их исходный порядок следования.*/
    static int[] Ex16(int[] Input) => Input.Where(i => i >= 0).ToArray();

    /*Дана целочисленная последовательность. Извлечь из нее все нечетные числа,
    сохранив их исходный порядок следования и удалив все вхождения
    повторяющихся элементов, кроме первых.*/
    static int[] Ex17(int[] Input) => Input.Where(i => i%2 != 0).Distinct().ToArray();

    /*Дана целочисленная последовательность. Извлечь из нее все четные
    отрицательные числа, поменяв порядок извлеченных чисел на обратный.*/
    static int[] Ex18(int[] Input) => Input.Where(i => i < 0 && i % 2 == 0).Reverse().ToArray();

    /*Дана цифра D (целое однозначное число) и целочисленная последовательность A.
    Извлечь из A все различные положительные числа, оканчивающиеся цифрой D
    (в исходном порядке). При наличии повторяющихся элементов удалять все их вхождения,
    кроме последних.*/
    static int[] Ex19(int D, int[] A) => A.Where(i => i > 0 && i%10 == D).Distinct().ToArray();

    /*Дана целочисленная последовательность. Извлечь из нее все
    положительные двузначные числа, отсортировав их по возрастанию.*/
    static int[] Ex20(int[] Input) => Input.Where(i => i >= 0 && Math.Abs(i) < 100).Order().ToArray();

    /*Дана строковая последовательность. Строки последовательности содержат
    только заглавные буквы латинского алфавита. Отсортировать последовательность
    по возрастанию длин строк,
    а строки одинаковой длины — в лексикографическом порядке по убыванию.*/
    static string[] Ex21(string[] Input) => Input.Order().OrderBy(i => i.Length).ToArray();

    /*Дано целое число K (> 0) и строковая последовательность A.
    Строки последовательности содержат только цифры и
    заглавные буквы латинского алфавита. Извлечь из A все строки длины K,
    оканчивающиеся цифрой, отсортировав их в лексикографическом порядке по возрастанию.*/
    static string[] Ex22(int K, string[] A) => A.Where(i => i.Length == K && Char.IsDigit(i.Last())).Order().ToArray();

    /* Дано целое число K (> 0) и целочисленная последовательность A.
    Начиная с элемента A с порядковым номером K, извлечь из A все
    нечетные двузначные числа, отсортировав их по убыванию.*/
    static int[] Ex23(int K, int[] A) => A.Skip(K).Where(i => i%2 != 0 && i < 100).OrderDescending().ToArray();

    /*Дано целое число K (> 0) и строковая последовательность A.
    Из элементов A, предшествующих элементу с порядковым номером K,
    извлечь те строки, которые имеют нечетную длину и начинаются с
    заглавной латинской буквы, изменив порядок следования извлеченных строк на обратный.*/
    static string[] Ex24(int K, string[] A) => A.Skip(K).Where(i => i.Length % 2 != 0 && Char.IsUpper(i.First())).Reverse().ToArray();

    /*Дана последовательность непустых строк A. Получить последовательность
    символов, каждый элемент которой является начальным символом
    соответствующей строки из A. Порядок символов должен быть обратным
    по отношению к порядку элементов исходной последовательности.*/
    static string[] Ex32(string[] a) => a.Select(i => i.First().ToString()).Reverse().ToArray();

    /*Дана целочисленная последовательность. Обрабатывая только положительные
    числа, получить последовательность их последних цифр и удалить в полученной
    последовательности все вхождения одинаковых цифр, кроме первого. Порядок
    полученных цифр должен соответствовать порядку исходных чисел.*/
    static int[] Ex33(int[] numbers) => numbers.Where(i => i >= 0).Select(i => i%10).Distinct().ToArray();

    /*Дана последовательность положительных целых чисел. Обрабатывая только
    нечетные числа, получить последовательность их строковых представлений и
    отсортировать ее в лексикографическом порядке по возрастанию.*/
    static string[] Ex34(int[] numbers) => numbers.Where(i => i%2 != 0).Select(i => i.ToString()).OrderDescending().ToArray();

    /*Дана целочисленная последовательность. Получить последовательность чисел,
    каждый элемент которой равен произведению соответствующего элемента
    исходной последовательности на его порядковый номер (1, 2, …).
    В полученной последовательности удалить все элементы, не являющиеся двузначными,
    и поменять порядок оставшихся элементов на обратный.*/
    static int[] Ex35(int[] numbers) => numbers.Where((elem, index) => elem < 100 && elem == index).Reverse().ToArray();

    /*Дана последовательность непустых строк. Получить последовательность символов,
    которая определяется следующим образом: если соответствующая строка
    исходной последовательности имеет нечетную длину, то в качестве символа
    берется первый символ этой строки; в противном случае берется последний символ строки.
    Отсортировать полученные символы по убыванию их кодов.*/
    static char[] Ex36(string[] str) => str.Select(i => i.Length % 2 == 0 ? i.Last() : i.First()).Order().ToArray();

    /*Дана строковая последовательность A. Строки последовательности содержат
    только заглавные буквы латинского алфавита. Получить новую
    последовательность строк, элементы которой определяются по
    соответствующим элементам A следующим образом: пустые строки в новую последовательность
    не включаются, а к непустым приписывается порядковый номер данной строки в
    исходной последовательности (например, если пятый элемент A имеет вид «ABC»,
    то в полученной последовательности он будет иметь вид «ABC5»).
    При нумерации должны учитываться и пустые строки последовательности A.
    Отсортировать полученную последовательность в лексикографическом порядке по возрастанию.*/
    static string[] Ex37(string[] A) => A.Select((element, index) => element + index).Where(i => i.Length > 1).ToArray();

    /*Дана целочисленная последовательность A. Получить новую последовательность чисел, элементы
    которой определяются по соответствующим элементам последовательности A следующим образом:
    если порядковый номер элемента A делится на 3 (3, 6, …), то этот элемент в новую последовательность не включается;
    если остаток от деления порядкового номера на 3 равен 1 (1, 4, …), то
    в новую последовательность добавляется удвоенное значение этого элемента;
    в противном случае (для элементов A с номерами 2, 5, …) элемент добавляется в новую последовательность без изменений.
    В полученной последовательности сохранить исходный порядок следования элементов.*/
    static int[] Ex38(int[] A) => A.Where((element, index) => index % 3 != 0).Select((element, index) => index % 3 == 1 ? element * 2 : element).ToArray();

    /*Дана строковая последовательность A. Получить последовательность цифровых символов,
    входящих в строки последовательности A (символы могут повторяться).
    Порядок символов должен соответствовать порядку строк A и порядку следования символов в
    каждой строке.*/
    static char[] Ex39(string[] A) => A.SelectMany(j => j.Where(i => Char.IsDigit(i))).ToArray();

    /*Даны целые числа K1 и K2 и целочисленные последовательности A и B.
    Получить последовательность, содержащую все числа из A, большие K1,
    и все числа из B, меньшие K2. Отсортировать полученную последовательность
    по возрастанию.*/
    static int[] Ex44(int k1, int k2, int[] a, int[] b) => a.Where(i => i > k1).Concat(b.Where(i => i < k2)).Order().ToArray();

    /*Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
    Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита.
    Получить последовательность, содержащую все строки из A длины L1
    и все строки из B длины L2. Отсортировать полученную последовательность
    в лексикографическом порядке по убыванию.*/
    static string[] Ex45(int l1, int l2, string[] A, string[] B) => A.Where(i => i.Length == l1).Concat(B.Where(i => i.Length == l2)).Order().ToArray();

    /*Даны последовательности положительных целых чисел A и B; все числа
    в каждой последовательности различны. Найти последовательность всех пар чисел,
    удовлетворяющих следующим условиям: первый элемент пары принадлежит
    последовательности A, второй принадлежит B, и оба элемента оканчиваются
    одной и той же цифрой. Результирующая последовательность называется
    внутренним объединением последовательностей A и B по ключу,
    определяемому последними цифрами исходных чисел.
    Представить найденное объединение в виде последовательности строк,
    содержащих первый и второй элементы пары, разделенные дефисом, например,
    «49-129». Порядок следования пар должен определяться
    исходным порядком элементов последовательности A,
    а для равных первых элементов — порядком элементов последовательности B.*/
    //static string[] Ex46(int[] A, int[] B) => A.Join(B, i => i%10, j => j%10, (i, j) => );

    /*Дана целочисленная последовательность A. Сгруппировать элементы последовательности A,
    оканчивающиеся одной и той же цифрой, и на основе этой группировки получить последовательность строк вида «D:S»,
    где D — ключ группировки (т. е. некоторая цифра, которой оканчивается хотя бы одно из чисел последовательности A),
    а S — сумма всех чисел из A, которые оканчиваются цифрой D. Полученную последовательность упорядочить по возрастанию ключей.
    Указание. Использовать метод GroupBy.*/
    static string[] Ex56(int[] A) => A.GroupBy(i => Math.Abs(i) % 10).Select(i => i.Key + ":" + i.Sum()).ToArray();

    /*Дана целочисленная последовательность. Среди всех элементов последовательности, оканчивающихся одной и той же цифрой,
    выбрать максимальный. Полученную последовательность максимальных элементов упорядочить по возрастанию их последних цифр.*/
    static int[] Ex57(int[] A) => A.GroupBy(i => Math.Abs(i) % 10).Select(i => i.Max()).OrderBy(i => i % 10).ToArray();

    /*Дана последовательность непустых строк. Среди всех строк, начинающихся с одного и того же символа,
    выбрать наиболее длинную. Если таких строк несколько, то выбрать первую по порядку их следования в
    исходной последовательности. Полученную последовательность строк упорядочить по возрастанию кодов их начальных символов.*/
    static string[] Ex58(string[] A) => A.GroupBy(i => i.First()).Select(i => i.MaxBy(j => j.Length)).OrderBy(i => i!.Length).ToArray()!;

    /*Дана последовательность непустых строк, содержащих только заглавные буквы латинского алфавита.
    Среди всех строк одинаковой длины выбрать первую в лексикографическом порядке (по возрастанию).
    Полученную последовательность строк упорядочить по убыванию их длин.*/
    static string[] Ex59(string[] A) => A.GroupBy(i => i.Length).Select(i => i.Min()).OrderByDescending(i => i!.Length).ToArray()!;

    /*Дана последовательность непустых строк A, содержащих
    только заглавные буквы латинского алфавита. Для всех строк,
    начинающихся с одной и той же буквы, определить их суммарную длину
    и получить последовательность строк вида «S-C», где S — суммарная длина всех строк
    из A, которые начинаются с буквы С. Полученную последовательность упорядочить
    по убыванию числовых значений сумм,
    а при равных значениях сумм — по возрастанию кодов символов C.*/
    static string[] Ex60(string[] str) => str.Select(i => new {chr = i.First(), Count = str.Sum(j => j.First() == i.First() ? j.Length : 0)}).Distinct().OrderBy(i => i.chr).OrderByDescending(i => i.Count).Select(i => i.Count.ToString() + "-" + i.chr.ToString()).ToArray();
}